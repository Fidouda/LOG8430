package Commands;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.util.HashMap;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

public class DynamicClassInterface extends java.lang.ClassLoader{
	
	private HashMap<String, Class<?>> classes = new HashMap<String, Class<?>>();
private List<ICommand> classList = new ArrayList<ICommand>();
	
	/**
	 * Methode qui permet de charger dynamiquement les classes se retrouvant dans le dossier command
	 * @return	La liste des commandes chargees dynamiquement
	 */
	public List<ICommand> loadCommands(){
		File folder = new File("./command");
		File[] listOfFiles = folder.listFiles();
		classList.clear();
	    for (File file : listOfFiles) {
	      if (file.isFile()) {
	        try {
				Object command;
				try {
					//Ignorer le fichier .DS_Store sur Mac os
					if(!file.getName().equals(".DS_Store")){
						command = (loadClass(file.getName(), true)).newInstance();
						classList.add((ICommand)command);
					}
				} catch (InstantiationException | IllegalAccessException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} catch (ClassNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	      } 
	    }
	    return classList;
	}
	
	public synchronized Class<?> loadClass(String className, boolean resolveIt) 
	         throws ClassNotFoundException { 
	         Class<?> result; 
	         byte classData[]; 
	         System.out.println(" >>>>>> Load class : "+className); 
	         /* Check our local cache of classes */ 
	         result = (Class<?>)classes.get(className); 
	         if (result != null) { 
	             System.out.println(" >>>>>> returning cached result."); 
	             return result; 
	         } 
	       //On verifie qu'il ne s'agit pas d'une classe se retrouvant dans le classpath ou d'une classe system
	 		try { 
	 		    result = super.findSystemClass(className); 
	 		    return result; 
	 		    } 
	 		catch (ClassNotFoundException e) { 

	 		} 
	 		//On recupere le data de la classe a chargee
	 		classData = getClass(className); 
	 		if (classData == null) { 
	 		    throw new ClassNotFoundException(); 
	 		} 
	 		//On finalise le processus de chargement de la classe
	 		result = (Class<?>) defineClass(composeFileName(className),classData, 0, classData.length);
	 		if (resolveIt) { 
	 		    resolveClass(result); 
	 		}
	 		classes.put(className, result); 
	 		 
	 		return result; 
	}       
	
	
	
	private byte[] getClass(String className){
		//Les commandes sont supposees se retrouvees dans le dossier command du projet
		String path = "command//" + className;
		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
		byte[] buffer = new byte[8000];

		int count;
		    
		try {
			InputStream is = new FileInputStream(path);
			while ((count = is.read(buffer)) > 0) {
				bytes.write(buffer, 0, count);
			}
			is.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
		 
		return bytes.toByteArray();
	}
	
	private String composeFileName(String className){
		String[] split = className.split("\\.");

		return "model." + split[0];
	}
	
		
	    public void invokeClassMethod(String classBinName, String methodName){
	    	try {
	   // Create a new JavaClassLoa
        ClassLoader classLoader = this.getClass().getClassLoader();

         
        // Load the target class using its binary name
        Class loadedMyClass = classLoader.loadClass(classBinName);
        System.out.println("Loaded class name: " + loadedMyClass.getName());
        // Create a new instance from the loaded class

        Constructor constructor = loadedMyClass.getConstructor();

        Object myClassObject = constructor.newInstance();

        // Getting the target method from the loaded class and invoke it using its name
        Method method = loadedMyClass.getMethod(methodName);
        
        System.out.println("Invoked method name: " + method.getName());
        method.invoke(myClassObject);
    	
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
		public void classReload() {
			File file = new File("c:\\myclasses\\");
			try {
			    // Convert File to a URL
			    URL url = file.toURL();          // file:/c:/myclasses/
			    URL[] urls = new URL[]{url};

			    // Create a new class loader with the directory
			    ClassLoader cl = new URLClassLoader(urls);

			    // Load in the class; MyClass.class should be located in
			    // the directory file:/c:/myclasses/com/mycompany
			    Class cls = cl.loadClass("com.mycompany.MyClass");
			} catch (MalformedURLException e) {
			} catch (ClassNotFoundException e) {
			}
			
		}
 }

