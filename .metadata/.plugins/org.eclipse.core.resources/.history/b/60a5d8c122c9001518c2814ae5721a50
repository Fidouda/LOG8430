package Commands;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;

import org.omg.CORBA.portable.InputStream;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

public class DynamicClassInterface extends ClassLoader{

	 public DynamicClassInterface(ClassLoader parent) {
	        super(parent);
	    }
	
		
	 public class CommandClassLoader extends java.lang.ClassLoader {
			
			private HashMap<String, Class<?>> classes = new HashMap<String, Class<?>>();
			private List<ICommand> classList = new ArrayList<ICommand>();
			
			/**
			 * Methode qui permet de charger dynamiquement les classes se retrouvant dans le dossier command
			 * @return	La liste des commandes chargees dynamiquement
			 */
			public List<ICommand> loadCommands(){
				File folder = new File("./command");
				File[] listOfFiles = folder.listFiles();
				classList.clear();
			    for (File file : listOfFiles) {
			      if (file.isFile()) {
			        try {
						Object command;
						try {
							//Ignorer le fichier .DS_Store sur Mac os
							if(!file.getName().equals(".DS_Store")){
								command = (loadClass(file.getName(), true)).newInstance();
								classList.add((ICommand)command);
							}
						} catch (InstantiationException | IllegalAccessException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					} catch (ClassNotFoundException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
			      } 
			    }
			    return classList;
			}

			/**
			 * Methode qui permet de charger dynamiquement une classe
			 */
			public synchronized Class<?> loadClass(String className, boolean resolveIt)
			         throws ClassNotFoundException { 
				Class<?> result; 
				byte classData[]; 
				//On verifie qu'on a pas deja chargee la classe, sinon on aura une erreur
				result = (Class<?>)classes.get(className); 
				if (result != null) { 
				    return result; 
				}
				//On verifie qu'il ne s'agit pas d'une classe se retrouvant dans le classpath ou d'une classe system
				try { 
				    result = super.findSystemClass(className); 
				    return result; 
				    } 
				catch (ClassNotFoundException e) { 

				} 
				//On recupere le data de la classe a chargee
				classData = getClass(className); 
				if (classData == null) { 
				    throw new ClassNotFoundException(); 
				} 
				//On finalise le processus de chargement de la classe
				result = (Class<?>) defineClass(composeFileName(className),classData, 0, classData.length);
				if (resolveIt) { 
				    resolveClass(result); 
				}
				classes.put(className, result); 
				 
				return result; 
			} 
			
			/**
			 * Methode qui permet d'obtenir le data byte d'une classe
			 * @param className	Le nom de la classe a charger
			 * @return	Le data byte de la classe a charger 
			 */
			private byte[] getClass(String className){
				//Les commandes sont supposees se retrouvees dans le dossier command du projet
				String path = "command//" + className;
				ByteArrayOutputStream bytes = new ByteArrayOutputStream();
				byte[] buffer = new byte[8000];

				int count;
				    
				try {
					InputStream is = new FileInputStream(path);
					while ((count = is.read(buffer)) > 0) {
						bytes.write(buffer, 0, count);
					}
					is.close();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} 
				 
				return bytes.toByteArray();
			}
			
			/**
			 * Methode qui s'occupe de composer le binary name de la classe pour le class loader
			 * @param className	Le nom de la classe
			 * @return	Le BinaryName de la classe
			 */
			private String composeFileName(String className){
				String[] split = className.split("\\.");

				return "model." + split[0];
			}
	 }

